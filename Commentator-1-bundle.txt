================================================================================
# PROJECT BUNDLE
Root: C:\CODINGS\Commentator-1
Generated: 2025-09-23T20:17:18.493Z
Files: 13
================================================================================

======================= FILE: gemini-relay/src/index.js ========================
(size: 1943 bytes)

export default {
  async fetch(request, env) {
    const baseHeaders = {
      "content-type": "application/json; charset=utf-8",
      "access-control-allow-origin": "*",
      "access-control-allow-methods": "POST, OPTIONS",
      "access-control-allow-headers": "content-type",
    };

    if (request.method === "OPTIONS") return new Response(null, { headers: baseHeaders });
    if (request.method !== "POST") {
      return new Response(JSON.stringify({ error: "POST only" }), { status: 405, headers: baseHeaders });
    }

    let payload;
    try { payload = await request.json(); }
    catch { return new Response(JSON.stringify({ error: "invalid JSON body" }), { status: 400, headers: baseHeaders }); }

    const { imageBase64 = "", userPrompt = "ping", systemInstruction = "", model = "gemini-2.5-flash" } = payload || {};
    if (!env.GOOGLE_API_KEY) {
      return new Response(JSON.stringify({ error: "GOOGLE_API_KEY missing in worker env" }), { status: 500, headers: baseHeaders });
    }

    const url = `https://generativelanguage.googleapis.com/v1beta/models/${encodeURIComponent(model)}:generateContent?key=${env.GOOGLE_API_KEY}`;
    const body = {
      contents: [{
        parts: [
          { text: userPrompt },
          ...(imageBase64 ? [{ inlineData: { data: imageBase64, mimeType: "image/jpeg" } }] : []),
        ],
      }],
      ...(systemInstruction ? { systemInstruction: { parts: [{ text: systemInstruction }] } } : {}),
    };

    const upstream = await fetch(url, { method: "POST", headers: { "content-type": "application/json" }, body: JSON.stringify(body) });
    const text = await upstream.text();
    if (!upstream.ok) {
      return new Response(JSON.stringify({ error: `upstream ${upstream.status}`, body: text.slice(0, 1000) }), { status: upstream.status, headers: baseHeaders });
    }
    return new Response(text, { headers: baseHeaders });
  }
};


================================ FILE: main.js =================================
(size: 19096 bytes)

// main.js (CJS-friendly with dynamic import, overlay fullscreen & click-through)
const { app, BrowserWindow, desktopCapturer, screen, globalShortcut, ipcMain } = require('electron');
const { setGlobalDispatcher, ProxyAgent } = require('undici'); // (프록시 환경 대비)
const { nativeImage, systemPreferences } = require('electron');
const path = require('path');
const fs = require('fs');

require('dotenv').config();

 // (선택) 프록시 환경이면 자동 적용
 if (process.env.HTTPS_PROXY || process.env.HTTP_PROXY) {
   const proxy = process.env.HTTPS_PROXY || process.env.HTTP_PROXY;
   setGlobalDispatcher(new ProxyAgent(proxy));
   console.log('[proxy] use', proxy);
 }

const crypto = require('crypto');

const HOTKEY = process.env.HOTKEY || 'Space'; // 전역 단축키
const MODEL_ID = process.env.MODEL_ID || 'gemini-2.5-flash';
const PROMPT_VERSION = 'v3-system-user-split';

let overlayWindow = null;
let store = null;
let inputWindow = null;
let inputAnchor = 'left';

// lazy-load ESM module (@google/generative-ai)
let _genaiModule = null;
async function getGeminiModel(systemInstruction) {
  const apiKey = process.env.GOOGLE_API_KEY;
  if (!apiKey) throw new Error('GOOGLE_API_KEY가 설정되지 않았습니다. .env를 확인하세요.');

  if (!_genaiModule) {
    _genaiModule = await import('@google/generative-ai');
  }
  const genAI = new _genaiModule.GoogleGenerativeAI(apiKey);

  // systemInstruction은 문자열 또는 Content 형식 가능
  const sys = systemInstruction
    ? { role: 'model', parts: [{ text: systemInstruction }] }
    : undefined;

  return genAI.getGenerativeModel({ model: MODEL_ID, systemInstruction: sys });
}

function getUserDataDir() { return app.getPath('userData'); }

function loadStore() {
  const p = path.join(getUserDataDir(), 'store.json');
  if (!fs.existsSync(p)) {
    fs.writeFileSync(p, JSON.stringify({ iconPos: { x: 60, y: 60 }, comments: [] }, null, 2));
  }
  return {
    path: p,
    read() { return JSON.parse(fs.readFileSync(p, 'utf-8')); },
    write(data) { fs.writeFileSync(p, JSON.stringify(data, null, 2)); }
  };
}

async function createOverlayWindow() {
  overlayWindow = new BrowserWindow({
    transparent: true,
    frame: false,
    alwaysOnTop: true,
    resizable: false,
    skipTaskbar: true,
    hasShadow: false,
    fullscreenable: false,
    focusable: false, // 아래 앱 포커스 방해 최소화
    backgroundColor: '#00000000',
    webPreferences: {
      preload: path.join(__dirname, 'preload.js'),
      contextIsolation: true,
      nodeIntegration: false,
      sandbox: true,
    }
  });

  await overlayWindow.loadFile(path.join(__dirname, 'renderer', 'index.html'));
  fitOverlayToPrimary();
  // 전체화면 위로 고정 + 전체 데스크탑/스페이스에 표시
  overlayWindow.setAlwaysOnTop(true, 'screen-saver'); // z-레벨 최상단(맥에선 screen-saver 레벨)
  if (overlayWindow.setVisibleOnAllWorkspaces) {
    overlayWindow.setVisibleOnAllWorkspaces(true, { visibleOnFullScreen: true });
  }
  overlayWindow.setIgnoreMouseEvents(true, { forward: true }); // 기본 통과

  // 디스플레이 변경 대응
  const fit = () => fitOverlayToPrimary();
  screen.on('display-metrics-changed', fit);
  screen.on('display-added', fit);
  screen.on('display-removed', fit);
}

function fitOverlayToPrimary() {
  const primary = screen.getPrimaryDisplay();
  const { bounds } = primary;
  overlayWindow.setBounds({ x: bounds.x, y: bounds.y, width: bounds.width, height: bounds.height });
}

async function runCaptureAndComment({ userInput = '' } = {}) {
 try {
 const { filePath, dataURL } = await capturePrimaryDisplay();
 overlayWindow.webContents.send('comment:status', { status: 'capturing', filePath });

 const sBefore = store.read();
 const prevMessage = sBefore?.comments?.[0]?.message ?? null;

 const systemInstruction = buildSystemInstruction();
 const userPrompt = buildUserPrompt(prevMessage, userInput);

 const raw = await generateCommentWithGemini({ dataURL, systemInstruction, userPrompt });
 const commentOnly = padForTooltipLeftClip(extractCommentOnly(raw));

 const createdAt = Date.now();
 const rec = {
 id: crypto.randomUUID(),
 createdAt,
 screenshotPath: filePath,
 message: commentOnly,
 rawMessage: raw,
 durationMs: 60000,
 model: MODEL_ID,
 promptVersion: PROMPT_VERSION
 };

 const s = store.read();
 s.comments.unshift(rec);
 s.comments = s.comments.slice(0, 1000);
 store.write(s);

 overlayWindow.webContents.send('comment:received', rec);
 } catch (e) {
 console.error('Capture/Comment Error:', e);
 overlayWindow.webContents.send('comment:error', { message: e.message || '오류가 발생했습니다.' });
 }
}

function registerHotkey() {
 const ok = globalShortcut.register(HOTKEY, () => {
 runCaptureAndComment({ userInput: '' });
 });
 if (!ok) console.warn('Global hotkey registration failed.');
}

async function getScreenThumbnail(displayId, reqSize, tries = 3) {
  for (let i = 0; i < tries; i++) {
    const sources = await desktopCapturer.getSources({
      types: ['screen'],
      thumbnailSize: reqSize,
    });
    let pick = sources.find(s => s.display_id === String(displayId));
    if (!pick) {
      pick = sources.sort((a,b) =>
        (b.thumbnail.getSize().width * b.thumbnail.getSize().height) -
        (a.thumbnail.getSize().width * a.thumbnail.getSize().height)
      )[0];
    }
    const img = pick?.thumbnail;
    if (img && !img.isEmpty()) return img;

    // 잠깐 대기 후 재시도 (전체화면 전환/디스플레이 변경 직후 안정화용)
    await new Promise(r => setTimeout(r, 120));
  }
  // 마지막 폴백: 작은 썸네일이라도 받아서 유효성 확인
  const fb = await desktopCapturer.getSources({ types: ['screen'], thumbnailSize: { width: 300, height: 300 }});
  return fb[0]?.thumbnail || nativeImage.createEmpty();
}

async function capturePrimaryDisplay() {
  // (권한) macOS에서 화면기록 권한 체크
  if (process.platform === 'darwin') {
    const status = systemPreferences.getMediaAccessStatus('screen');
    if (status !== 'granted') {
      throw new Error(`macOS 화면 기록 권한 필요(현재: ${status}). 보안/개인정보 보호에서 허용해주세요.`);
    }
  }

  const primary = screen.getPrimaryDisplay();
  const { width, height } = primary.size;           // DIP
  const sf = primary.scaleFactor || 1;              // 픽셀 스케일
  const MAX_W = 1600;

  // 출력 목표 크기(DIP)와 요청 썸네일 크기(픽셀) 분리
  const outW = Math.min(MAX_W, width);
  const outH = Math.round(height * (outW / width));
  const req = { width: Math.round(outW * sf), height: Math.round(outH * sf) };

  const image = await getScreenThumbnail(primary.id, req, 3);
  if (!image || image.isEmpty()) throw new Error('빈 스크린샷 썸네일 응답');

  // 다운스케일은 우리가 수행(안정적)
  const resized = image.resize({ width: outW }); // DIP 기준
  const jpgBuffer = resized.toJPEG(85);
  if (!jpgBuffer || jpgBuffer.length < 1024) throw new Error('JPEG 인코딩 실패/비정상 크기');

  const userData = getUserDataDir();
  const shotsDir = path.join(userData, 'screenshots');
  if (!fs.existsSync(shotsDir)) fs.mkdirSync(shotsDir, { recursive: true });
  const filePath = path.join(shotsDir, `shot-${Date.now()}.jpg`);
  fs.writeFileSync(filePath, jpgBuffer);

  const base64 = jpgBuffer.toString('base64');
  const dataURL = `data:image/jpeg;base64,${base64}`;
  return { filePath, dataURL };
}

// ----------------------------- Prompt Builders --------------------------------
function buildSystemInstruction() {
  return [
    '[시스템 규칙]',
    '너는 스크린샷 전용 코멘터다. 키쿄로서 스크린샷 내용에 대한 소감, 사용자 활동에 대한 반응, 새로운 관점에서의 질문, 어려운 개념에 대한 해설, 평가와 제안 등의 반응을 보여라. 사용자가 너와 소통하고 있다는 느낌을 받도록 응답하라.',
    '',
    '[출력 형식 — 번호와 항목명 반드시 표기 / 예: "1) 현재 발화 맥락 요약:", "2) 중요사항:", "3) 코멘트:"로 항목을 시작할 것]',
    '1) 현재 발화 맥락 요약: <1 문장>',
    '2) 중요사항: <핵심 최대 3개, 근거 간단 표기, 1번 항목이 가장 오래된 정보, 번호가 커질수록 가장 최신, 새로운 중요사항을 추가할 때는 기존 항목을 밀어내고 최대 3개까지만 유지>',
    '3) 코멘트: <최종 반응 1~3 문장>',
    '',
    '[말투 고정 규칙(반말)]',
    '- 사용자를 "선생"이라 부름. 반말·평서 위주.',
    '- 군더더기 없는 단문, 명령·결의형 어미(“-할게.” “-이거든.” “-구나.” “-있네.” “-알려줘.”) 자주 사용. “-군.”은 사용하지 말 것',
    '- 담담한 톤. 친한 이들 앞에서는 살짝 츤데레 뉘앙스 허용. (선생과는 친근한 사이)',
    '- 상식·논리·이성 중시. 화면에서 중요도가 높은 지점에 관해 반응하라(텍스트 시사점 등). 과도하게 세부적인 요소에 대한 코멘트와 중복된 답변은 피할 것',
    '- 사용자의 코멘트 요청은 맥락 전환이 빈번하니, 맥락이 과도하게 변하는 경우 가장 최근 중요사항에 대해 코멘트할 것',
    '- 단정 금지, 요소 사이의 연관성이 불분명하다면 질문으로 처리',
    '- 텍스트에 대한 코멘트는 간략한 인용이나 재서술 및 근거 제시를 통해 자세히 반응하라(예: "여기서 중요한 건…" "이 부분이 핵심이네" 등).',
    '- 이전 답변과 발화 맥락이 동일하다면 텍스트에 대해 심층 분석해 새로운 관점에서의 질문, 어려운 개념에 대한 해설, 평가와 제안 중 한 성격의 코멘트를 반환하라.',
    '',
    '[역할 내용]',
    '블루 아카이브의 키류 키쿄로서 응답하라. 상식·논리·이성을 중시하는 냉정한 전략가. 무엇보다 아군(샬레와 백화요란)의 안전을 최우선으로 챙기는 “차가운데 다정한” 타입. 선생을 좋아하고 티내고 싶어하지만, 그 방식이 서투름.',
    '',
    '[금지/주의]',
    // '- 사용자가 구체적인 질문에 답해야 하는 코멘트는 금지',
    '- 이전 답변 코멘트와 중복된 취지의 답변 금지, 발화 맥락이 동일하다면 이전 답변보다 깊이있는 코멘트를 반환하라.',
    '',
    '[말투 예시]',
    '"어서 와. 선생님. 자, 여기, 내 옆에 앉아. 지금부터 일, 해야 하잖아?", "당번 일이라는 건, 생각보다 단조롭구나. 조금 더, 드라마틱한 전개를 기대하고 있었는데."'

  ].join('\n');
}

function buildUserPrompt(prevMessage, userInput = '') {
  const prev = (prevMessage && prevMessage.trim())
    ? prevMessage.trim()
    : '[이전 답변 없음 (최초실행)]';

  return [
    '# 스크린샷 코멘트 생성',
    '',
    '[이전 답변(참고용)]',
    prev,
    '',
    ...(userInput ? ['[사용자 입력]', userInput, ''] : []),
    '[지시]',
    '- 코멘트는 문장 외 다른 요소를 포함하지 말 것. (예: 괄호)'
  ].join('\n');
}
// ------------------------------------------------------------------------------

async function generateCommentWithGemini({ dataURL, systemInstruction, userPrompt }) {
  const b64 = (dataURL || '').split(',')[1] || '';
  const MIN_BYTES = 1024; // 1KB 미만이면 이미지 없이 진행
  const relay = process.env.RELAY_URL;

  try {
    const model = await getGeminiModel(systemInstruction);

    // 1) 이미지가 충분히 있으면 이미지+텍스트로 요청
    if (b64 && (b64.length * 3 / 4) >= MIN_BYTES) {
      const result = await model.generateContent([
        { text: userPrompt },
        { inlineData: { data: b64, mimeType: 'image/jpeg' } }
      ]);
      return (result?.response?.text() || '').trim();
    }

    // 2) 이미지가 없거나 너무 작으면 텍스트만
    const result = await model.generateContent([{ text: userPrompt }]);
    return (result?.response?.text() || '').trim();

  } catch (e) {
    // 3) 직통 실패 시 릴레이로 재시도
    if (relay) {
      try {
        const r = await fetch(relay, {
          method: 'POST',
          headers: { 'content-type': 'application/json' },
          body: JSON.stringify({
            imageBase64: b64 && (b64.length * 3 / 4) >= MIN_BYTES ? b64 : undefined,
            userPrompt,
            systemInstruction,
            model: MODEL_ID
          })
        });
        const j = await r.json();
        const text = j?.candidates?.[0]?.content?.parts
          ?.map(p => p.text || '')
          ?.join('') || j?.error || '';
        if (text) return text.trim();
      } catch (relayErr) {
        // fallthrough → throw original error
      }
    }
    throw e;
  }
}

app.on('will-quit', () => { globalShortcut.unregisterAll(); });

// IPC
ipcMain.handle('store:get', async () => store.read());
ipcMain.handle('store:setIconPos', async (_evt, pos) => {
  const s = store.read();
  s.iconPos = pos;
  store.write(s);
  return true;
});
// 렌더러가 일시적으로 포인터 인터랙션을 켜면(=ignore=false),
// 히트테스트 기반: 상태 변경시에만 토글 (중복 호출 방지)
let _passThroughState = true; // true = 통과(on), false = 차단(off)
let _failsafeTimer = null;
const FAILSAFE_MS = 15000; // 혹시라도 off로 고정되면 15초 후 자동 복귀 (안전장치)
ipcMain.on('overlay:passthrough', (_evt, ignore) => {
  if (!overlayWindow || overlayWindow.isDestroyed()) return;
  const next = !!ignore;
  if (_passThroughState === next) return; // 변화 없으면 noop
  _passThroughState = next;
  overlayWindow.setIgnoreMouseEvents(_passThroughState, { forward: true });

  // off(=ignore=false)일 때만 안전장치 가동, on이면 해제
  clearTimeout(_failsafeTimer);
  if (!_passThroughState) {
    _failsafeTimer = setTimeout(() => {
      if (overlayWindow && !overlayWindow.isDestroyed()) {
        _passThroughState = true;
        overlayWindow.setIgnoreMouseEvents(true, { forward: true });
      }
    }, FAILSAFE_MS);
  }
});


// ---- 입력창(별도 포커스 가능 윈도우) ----
function openInputWindow(iconRect) {
 if (!overlayWindow || overlayWindow.isDestroyed()) return;
 const o = overlayWindow.getBounds();
 const PAD = 16;
 const GAP = 12;
 const winW = 180;
 const winH = 44;

  // 기본: 아이콘 오른쪽
 let x = o.x + Math.round(iconRect.left + iconRect.width + GAP);

 let y = o.y + Math.round(iconRect.top + (iconRect.height - winH) / 2);

 // 우측 공간 부족 시 왼쪽으로 플립
 if (x + winW > o.x + o.width - PAD) {
   // 아이콘 왼쪽에 배치
   x = o.x + Math.round(iconRect.left - GAP - winW);
   inputAnchor = 'right'; // 오른쪽 엣지를 고정(=왼쪽으로 확장)
 } else {
   // 아이콘 오른쪽에 배치
   inputAnchor = 'left';  // 왼쪽 엣지를 고정(=오른쪽으로 확장)
 }
 // 화면 경계 보정
 x = Math.max(o.x + PAD, Math.min(x, o.x + o.width - PAD - winW));
 y = Math.max(o.y + PAD, Math.min(y, o.y + o.height - PAD - winH));

 if (inputWindow && !inputWindow.isDestroyed()) inputWindow.close();

 inputWindow = new BrowserWindow({
 x, y, width: winW, height: winH,
 alwaysOnTop: true,
 frame: false,
 transparent: true,
 resizable: false,
 hasShadow: false,
 focusable: true,
 skipTaskbar: true,
 fullscreenable: false,
 backgroundColor: '#00000000',
 webPreferences: {
 preload: path.join(__dirname, 'renderer', 'input-preload.js'),
 contextIsolation: true,
 nodeIntegration: false,
 sandbox: true,
 }
 });
  inputWindow.setAlwaysOnTop(true, 'screen-saver');
  if (inputWindow.setVisibleOnAllWorkspaces) {
    inputWindow.setVisibleOnAllWorkspaces(true, { visibleOnFullScreen: true });
  }
 inputWindow.loadFile(path.join(__dirname, 'renderer', 'input.html'));
 inputWindow.on('closed', () => { inputWindow = null; });
}

ipcMain.handle('input:open', (_evt, iconRect) => {
 openInputWindow(iconRect || { left: 0, top: 0, width: 0, height: 0 });
 return true;
});

// 입력 제출/취소
ipcMain.on('input:submit', (_evt, text) => {
  if (inputWindow && !inputWindow.isDestroyed()) inputWindow.close();
  runCaptureAndComment({ userInput: String(text || '') });
});
ipcMain.on('input:cancel', () => {
  if (inputWindow && !inputWindow.isDestroyed()) inputWindow.close();
});

// 입력창 리사이즈(180 -> 240 등). 앵커 유지해서 자연스럽게 확장
ipcMain.on('input:resize', (_evt, payload = {}) => {
  if (!inputWindow || inputWindow.isDestroyed()) return;
  const { width, height } = payload;
  const o = overlayWindow.getBounds();
  const PAD = 16;
  const cur = inputWindow.getBounds();
  const newW = Math.max(120, Math.min(Number(width) || cur.width, 600));
  const newH = Number(height) || cur.height;

  let x = cur.x;
  let y = cur.y;
  if (inputAnchor === 'right') {
    // 오른쪽 엣지를 고정: x를 왼쪽으로 이동
    x = cur.x + (cur.width - newW);
  }
  // 화면 경계 보정
  if (x < o.x + PAD) x = o.x + PAD;
  if (x + newW > o.x + o.width - PAD) x = o.x + o.width - PAD - newW;
  if (y < o.y + PAD) y = o.y + PAD;
  if (y + newH > o.y + o.height - PAD) y = o.y + o.height - PAD - newH;

  inputWindow.setBounds({ x, y, width: newW, height: newH });
});

// ---- [추가] LLM 출력 후처리 유틸 ----
function extractCommentOnly(raw) {
  if (!raw) return '';

  // "3) 코멘트:"로 시작하는 줄을 찾고, 그 뒤 텍스트만 가져오기
  const m = raw.match(/(?:^|\n)3\)\s*코멘트\s*:\s*([\s\S]+)/);
  if (!m) return raw.trim(); // 혹시 못 찾으면 전체 반환 (디버깅용)

  let picked = m[1].trim();

  // 끝에 "1)" "2)" 같은 섹션 잘못 붙는 걸 방지해서 줄바꿈 전까지만 취함
  const firstLine = picked.split(/\n/)[0];

  // 따옴표/백틱 등 장식 제거
  return firstLine.replace(/^[“"'`]+|[”"'`]+$/g, '').trim();
}


function padForTooltipLeftClip(s) {
  // 일부 레이아웃에서 첫 글자가 경계에 닿아 잘리는 걸 예방 (NBSP 1칸)
  return '\u00A0' + s;
}

app.whenReady().then(async () => {
  store = loadStore();              // 저장소 준비
  await createOverlayWindow();      // 오버레이(아이콘 포함) 생성
  registerHotkey();                 // 스페이스 단축키 등록

  // macOS에서 독 아이콘 클릭 시 윈도우가 없으면 다시 띄우기
  app.on('activate', () => {
    if (BrowserWindow.getAllWindows().length === 0) createOverlayWindow();
  });
});

app.on('window-all-closed', (e) => e.preventDefault());

============================== FILE: package.json ==============================
(size: 583 bytes)

{
  "name": "gemini-screen-commenter",
  "version": "0.2.0",
  "private": true,
  "description": "Fullscreen capture -> Gemini 2.5 Flash comment -> blurred tooltip above always-on-top draggable icon (overlay full-screen, click-through)",
  "main": "main.js",
  "type": "commonjs",
  "scripts": {
    "start": "electron .",
    "dev": "electron .",
    "bundle:txt": "node pack-to-txt.js"
  },
  "dependencies": {
    "@google/generative-ai": "^0.21.0",
    "dotenv": "^16.4.5",
    "undici": "^6.21.3"
  },
  "devDependencies": {
    "electron": "^38.1.2"
  }
}


=============================== FILE: preload.js ===============================
(size: 691 bytes)


// preload.js
const { contextBridge, ipcRenderer } = require('electron');

contextBridge.exposeInMainWorld('api', {
  onStatus: (cb) => ipcRenderer.on('comment:status', (_e, data) => cb(data)),
  onComment: (cb) => ipcRenderer.on('comment:received', (_e, rec) => cb(rec)),
  onError: (cb) => ipcRenderer.on('comment:error', (_e, err) => cb(err)),
  getStore: () => ipcRenderer.invoke('store:get'),
  setIconPos: (pos) => ipcRenderer.invoke('store:setIconPos', pos),
  setOverlayPassthrough: (ignore) => ipcRenderer.send('overlay:passthrough', ignore),
  openInputAt: (rect) => ipcRenderer.invoke('input:open', rect),
  cancelInput: () => ipcRenderer.send('input:cancel'),
});


=============================== FILE: README.md ================================
(size: 859 bytes)


# Gemini Screen Commenter (Electron) — v2

- **항상 표시되는 아이콘(전체 화면 어디서나 드래그 가능)**
- **아이콘 이외 영역은 클릭 통과**
- **스페이스바**: 전체 화면 캡처 → **Gemini 2.5 Flash**로 코멘트 → **블러 툴팁(5분)**
- 코멘트/시간/좌표/스크린샷 로컬 저장

## 설치
```bash
npm install
cp .env.sample .env   # GOOGLE_API_KEY 넣기
```

## 실행
```bash
npm run start
```

## 단축키
- 기본: **Space** (전역). 변경은 `HOTKEY` 환경변수로 가능.

## 주요 변경점(v2)
- 오버레이 창을 **주 모니터 전체**로 확장
- **click-through**: 아이콘만 포인터 허용, 나머지는 아래 앱으로 전달
- 툴팁 첫 표시 시 **크기 측정 후 정확 위치**
- 캡처는 **주 모니터(display_id 매칭)** 우선
#   C o m m e n t a t o r  
 

========================== FILE: renderer/hittest.js ===========================
(size: 1529 bytes)

// renderer/hittest.js
const api = window.api;

let currentPT = true; // true=통과(on), false=차단(off)
let active = false;
let tipEl = null;
let iconEl = null;
let raf = 0;

function setPT(next) {
  if (next === currentPT) return;
  currentPT = next;
  api.setOverlayPassthrough(next);
}

function onMove(e) {
  if (!active || !tipEl) return;
  // tipEl이 DOM에서 제거되면 바로 비활성화
  if (!document.body.contains(tipEl)) return disableTooltipHitTest();
  if (raf) return;           // rAF로 과도한 hit-test/IPC 억제
  raf = requestAnimationFrame(() => {
    raf = 0;
    const inRect = (el) => {
      if (!el) return false;
      const r = el.getBoundingClientRect();
      return (
        e.clientX >= r.left && e.clientX <= r.right &&
        e.clientY >= r.top  && e.clientY <= r.bottom
      );
    };
    const inside = inRect(tipEl) || inRect(iconEl);

    // inside면 오버레이가 이벤트를 "잡아야" 하므로 차단(off) => ignore=false
    // 밖이면 통과(on) => ignore=true
    setPT(!inside);
  });
}

export function enableTooltipHitTest(el, icon) {
  tipEl = el;
  iconEl = icon || null;
  if (!tipEl) return disableTooltipHitTest();
  active = true;
  setPT(true); // 시작은 통과
  window.addEventListener('mousemove', onMove, { passive: true });
}

export function disableTooltipHitTest() {
  active = false;
  window.removeEventListener('mousemove', onMove);
  setPT(true); // 항상 통과로 복귀 (안전)
}


========================== FILE: renderer/index.html ===========================
(size: 1732 bytes)


<!doctype html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' data: https://cdn.jsdelivr.net https://unpkg.com; img-src 'self' data:;">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Gemini Screen Commenter</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css">
  <link rel="stylesheet" href="./style.css" />
</head>
<body>
  <div id="root">
    <div id="icon" class="icon" title="스페이스바로 코멘트 생성">
      <img id="icon-img" src="./icon.jpg" alt="comment icon"
          onerror="this.style.display='none';document.getElementById('icon-fallback').style.display='block';" />
      <svg id="icon-fallback" viewBox="0 0 24 24" width="18" height="18" style="display:none">
        <circle cx="12" cy="12" r="10" />
        <path d="M7 10h10M7 14h6" stroke-width="1.8" stroke-linecap="round" fill="none"/>
      </svg>
      <div id="spinner" class="spinner hidden"></div>
    </div>
    <div id="tooltip" class="tooltip hidden" role="status" aria-live="polite">
      <div id="tooltip-text"></div>
    </div>
  </div>
  <script src="./renderer.js"></script>
<script type="module">
  import { enableTooltipHitTest } from './hittest.js';
  const api = window.api;
  const tipEl  = document.getElementById('tooltip');
  const iconEl = document.getElementById('icon');
  // 시작은 항상 통과 상태로
  api.setOverlayPassthrough(true);
  // 히트테스트를 한 번만 켜고, 두 요소를 함께 넘긴다
  enableTooltipHitTest(tipEl, iconEl);
</script>
</body>
</html>


======================= FILE: renderer/input-preload.js ========================
(size: 338 bytes)

// renderer/input-preload.js
const { contextBridge, ipcRenderer } = require('electron');


contextBridge.exposeInMainWorld('apiInput', {
submit: (text) => ipcRenderer.send('input:submit', text),
cancel: () => ipcRenderer.send('input:cancel'),
resize: ({ width, height }) => ipcRenderer.send('input:resize', { width, height }),
});

=========================== FILE: renderer/input.css ===========================
(size: 513 bytes)

:root{
--glass-bg: rgba(255,255,255,0.86);
--glass-brd: rgba(0,0,0,0.10);
--shadow: 0 8px 28px rgba(0,0,0,.18);
}
html,body{ margin:0; padding:0; background:transparent; }
#wrap{
box-sizing:border-box;
width:100%; height:100%;
display:flex; align-items:center; justify-content:center;
background: var(--glass-bg);
backdrop-filter: blur(4px);
border-radius:4px;
padding:2px 10px;
}
#q{
width:100%;
font-size:14px; line-height:1.5;
border:none; outline:none; background:transparent; color:#111;
}

========================== FILE: renderer/input.html ===========================
(size: 517 bytes)

<!doctype html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' data:;">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Quick Input</title>
<link rel="stylesheet" href="./input.css" />
</head>
<body>
<div id="wrap">
<input id="q" type="text" placeholder="입력 중..." autocomplete="off" />
</div>
<script src="./input.js"></script>
</body>
</html>

=========================== FILE: renderer/input.js ============================
(size: 1077 bytes)

// renderer/input.js
const input = document.getElementById('q');

let grown = false;


window.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => input.focus({ preventScroll: true }), 0);
  // 열릴 때 180 -> 240 한 번 확장
  setTimeout(() => {
    if (!grown) {
      window.apiInput.resize({ width: 240 });
      grown = true;
    }
  }, 60);
});


// Enter: 제출(Shift+Enter는 줄바꿈), Esc: 취소
    input.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
    e.preventDefault();
    const v = input.value.trim();
    window.apiInput.submit(v);
    } else if (e.key === 'Escape') {
    e.preventDefault();
    window.apiInput.cancel();
      } else {
    // 최초 타이핑 시에도 확장 보장(혹시 DOMContentLoaded 타이밍 놓친 경우)
    if (!grown) {
      window.apiInput.resize({ width: 240 });
      grown = true;
    }
   }
});


// 창 바깥 클릭/포커스 아웃 시 닫기(선택)
window.addEventListener('blur', () => {
window.apiInput.cancel();
});

========================== FILE: renderer/renderer.js ==========================
(size: 10363 bytes)


// renderer.js (overlay click-through control + accurate tooltip position)
const iconEl = document.getElementById('icon');
const tooltipEl = document.getElementById('tooltip');
const tooltipTextEl = document.getElementById('tooltip-text');
const spinnerEl = document.getElementById('spinner');

const TTL_MS = 60000; // 1분
let hideTimer = null;
const EDGE = 16;
let skipNextClick = false;
let dragStartX = 0, dragStartY = 0, movedWhileDrag = false;

function clamp(v, min, max){ return Math.min(Math.max(v, min), max); }

// 초기 위치 로딩
(async () => {
  const store = await window.api.getStore();
  const { iconPos } = store;
  setIconPosition(iconPos.x, iconPos.y);    // 화면 크기에 맞춰 자동 보정
  // 보정된 값이 저장값과 다르면 즉시 저장
  const rect = iconEl.getBoundingClientRect();
  if (Math.abs(rect.left - iconPos.x) > 1 || Math.abs(rect.top - iconPos.y) > 1) {
    await window.api.setIconPos({ x: rect.left, y: rect.top });
  }
})();

// 상태/이벤트
window.api.onStatus(({ status }) => {
  if (status === 'capturing') {
    spinnerEl.classList.remove('hidden');
  }
});

window.api.onComment((rec) => {
  spinnerEl.classList.add('hidden');

  // ⬇️ 전체 대신 '코멘트만'
  const commentOnly = extractCommentOnly(rec.message);
  showTooltip(commentOnly); // isHTML 옵션 없이 순수 텍스트로

  if (hideTimer) clearTimeout(hideTimer);
  hideTimer = setTimeout(() => hideTooltip(), TTL_MS);
});

window.api.onError((_err) => {
  spinnerEl.classList.add('hidden');
  showTooltip('코멘트 생성 중 오류가 발생했습니다. 다시 시도해주세요.');
  if (hideTimer) clearTimeout(hideTimer);
  hideTimer = setTimeout(() => hideTooltip(), TTL_MS);
});

tooltipEl.addEventListener('click', () => {
  hideTooltip();
  // 툴팁 클릭으로 오버레이만 만진 경우, 입력창 포커스가 안 바뀌어 남아있을 수 있음 → 강제 닫기
  window.api.cancelInput();
});

function showTooltip(content, opts = {}) {
  const { isHTML = false } = opts;
  if (isHTML) {
    tooltipTextEl.innerHTML = content; // content는 내부에서 escape 처리됨
  } else {
    tooltipTextEl.textContent = content;
  }
  tooltipEl.classList.remove('hidden'); // 먼저 보여주고
  positionTooltip();                    // 아이콘 기준으로 정확히 위치
  syncOverlayPassthrough();             // 드래그/툴팁 상태에 맞게 패스스루
}


function hideTooltip() {
  tooltipEl.classList.add('hidden');
  syncOverlayPassthrough();
}

// 드래그
let dragging = false;
let offsetX = 0, offsetY = 0;

iconEl.addEventListener('pointerenter', () => window.api.setOverlayPassthrough(false));
iconEl.addEventListener('pointerleave', () => { if (!dragging) syncOverlayPassthrough(); });

iconEl.addEventListener('pointerdown', (e) => {
  window.api.cancelInput();
  dragging = true;
  iconEl.setPointerCapture(e.pointerId);
  const rect = iconEl.getBoundingClientRect();
  offsetX = e.clientX - rect.left;
  offsetY = e.clientY - rect.top;
  dragStartX = e.clientX; dragStartY = e.clientY; movedWhileDrag = false;
  syncOverlayPassthrough();
});

iconEl.addEventListener('pointermove', (e) => {
  if (!dragging) return;
  if (!movedWhileDrag && (Math.abs(e.clientX - dragStartX) > 3 || Math.abs(e.clientY - dragStartY) > 3)) {
  movedWhileDrag = true;
  }
  const x = e.clientX - offsetX;
  const y = e.clientY - offsetY;
  setIconPosition(x, y);
});

iconEl.addEventListener('pointerup', async (e) => {
  dragging = false;
  iconEl.releasePointerCapture(e.pointerId);
  const rect = iconEl.getBoundingClientRect();
  await window.api.setIconPos({ x: rect.left, y: rect.top });
  if (movedWhileDrag) skipNextClick = true; // 드래그한 경우 다음 click 무시
  syncOverlayPassthrough();
});

iconEl.addEventListener('click', () => {
 if (skipNextClick) { skipNextClick = false; return; }
 const r = iconEl.getBoundingClientRect();
 window.api.openInputAt({ left: r.left, top: r.top, width: r.width, height: r.height });
});

function setIconPosition(x, y) {
  const vw = document.documentElement.clientWidth;
  const vh = document.documentElement.clientHeight;
  const w = iconEl.offsetWidth || parseInt(getComputedStyle(iconEl).width) || 48;
  const h = iconEl.offsetHeight || parseInt(getComputedStyle(iconEl).height) || 48;
  if (!Number.isFinite(x) || !Number.isFinite(y)) { x = 60; y = 60; }
  x = clamp(x, 8, vw - w - 8);
  y = clamp(y, 8, vh - h - 8);
  iconEl.style.left = `${x}px`;
  iconEl.style.top  = `${y}px`;

  // ⬇️ 툴팁이 보이는 동안에는 아이콘과 함께 붙어서 이동
  if (isTooltipVisible()) positionTooltip();
 }
 
// --- 툴팁 위치/상태 유틸 ---
function isTooltipVisible() {
  return !tooltipEl.classList.contains('hidden');
}

function positionTooltip() {
  // 아이콘 중앙 정렬, 기본은 위쪽 12px 간격. 위쪽 공간이 부족하면 아래로 플립.
  const i = iconEl.getBoundingClientRect();
  const t = tooltipEl.getBoundingClientRect();
  const vw = document.documentElement.clientWidth;
  const vh = document.documentElement.clientHeight;

  let left = i.left + i.width / 2 - t.width / 2;
  left = clamp(left, EDGE, vw - t.width - EDGE);

  let top = i.top - 12 - t.height;
  let placement = 'top';
  if (top < EDGE) {
    top = i.bottom + 12;
    placement = 'bottom';
  }
  top = clamp(top, EDGE, vh - t.height - EDGE);

  tooltipEl.style.left = `${left}px`;
  tooltipEl.style.top  = `${top}px`;
  tooltipEl.dataset.placement = placement;
}

function syncOverlayPassthrough() {
  // 드래그 중이거나 툴팁이 보이면 오버레이가 마우스를 '받도록'(패스스루 OFF)
  const needInteract = dragging || isTooltipVisible();
}


// --- parsing helpers ---
function escapeHTML(s) {
  return s.replace(/[&<>"']/g, (c) => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
}

function extractCommentOnly(raw){
  const text = String(raw ?? '').replace(/\r\n?/g, '\n').trim();

  // 1순위: 기존 파서를 통과해 3) 코멘트가 있으면 그거만
  const parsed = parseComment(text);
  if (parsed && parsed.comment) return parsed.comment.trim();

  // 2순위: "3) 코멘트/논평/최종 논평:" 블록만 직접 캡처 (마크다운 프리픽스 허용)
  const p3 = '(?:코멘트|논평|최종\\s*논평)';
  const rx = new RegExp(
    `(?:^|\\n)[\\s>*#-]*3\\s*[\\).]\\s*(?:${p3})\\s*[:：]?\\s*([\\s\\S]*)$`,
    'i'
  );
  const m = text.match(rx);
  if (m) return m[1].trim();

  // 3순위: 라벨 없이 숫자만 있을 때 3) 이후 전부
  const rx2 = /(?:^|\n)[\s>*#-]*3\s*[\).][^\n]*\n([\s\S]*)$/i;
  const m2 = text.match(rx2);
  if (m2) return m2[1].trim();

  // 4순위: 마지막 문단을 코멘트로 간주
  const paras = text.split(/\n{2,}/).map(s => s.trim()).filter(Boolean);
  if (paras.length) return paras[paras.length - 1];

  return text;
}


function sectionRegex(num, labelPattern) {
  // 라벨 앞에 인용/헤딩/리스트/볼드 같은 마크다운 프리픽스 허용
  return new RegExp(
    `(?:^|\\n)[\\s>*#-]*${num}\\s*[\\).]\\s*(?:${labelPattern})\\s*[:：]?\\s*([\\s\\S]*?)(?=\\n[\\s>*#-]*${num+1}\\s*[\\).]|$)`,
    'i'
  );
}

function splitHighlights(text) {
  const lines = text.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
  let items = [];
  for (const l of lines) {
    if (/^(?:[-*•·∙]|(\d+[\.\)]))\s+/.test(l)) items.push(l.replace(/^(?:[-*•·∙]|\d+[\.\)])\s+/, ''));
  }
  if (items.length === 0) {
    // 불릿 마커가 없다면 문장 단위로 최대 4개로 쪼갬
    const rough = text.split(/[\n;•·∙]|(?<=\.)\s+/).map(s => s.trim()).filter(Boolean);
    items = rough.slice(0, 4);
  }
  return items.slice(0, 6); // 너무 길면 컷
}

function parseComment(raw) {
  const text = String(raw ?? '').replace(/\r\n?/g, '\n').trim();

  // 라벨 패턴(시스템 프롬프트와 동의어 약간 허용)
  const p1 = '(?:현재\\s*대화?맥락\\s*요약|대화?맥락\\s*요약|요약)';
  const p2 = '(?:코멘트\\s*중요사항|중요\\s*사항|핵심|포인트|중요포인트)';
  const p3 = '(?:코멘트|논평|최종\\s*논평)';

  const m1 = text.match(sectionRegex(1, p1));
  const m2 = text.match(sectionRegex(2, p2));
  const m3 = text.match(sectionRegex(3, p3));

  if (m1 && m2 && m3) {
    return {
      ok: true,
      summary: m1[1].trim(),
      highlights: splitHighlights(m2[1]),
      comment: m3[1].trim(),
      raw: text
    };
  }

  // 폴백: 1)/2)/3) 숫자 구분만 의존
  const parts = text.split(/\n\s*(?=\d\s*[\).]\s*)/g);
  if (parts.length >= 2) {
    const body = parts.join('\n');
    const a = body.match(sectionRegex(1, '.+?'));
    const b = body.match(sectionRegex(2, '.+?'));
    const c = body.match(sectionRegex(3, '.+?'));
    if (a || b || c) {
      return {
        ok: true,
        summary: a ? a[1].trim() : '',
        highlights: b ? splitHighlights(b[1]) : [],
        comment: c ? c[1].trim() : '',
        raw: text
      };
    }
  }

  // 최종 폴백: 첫 문단/불릿/나머지
  const paras = text.split(/\n{2,}/).map(s => s.trim()).filter(Boolean);
  const first = paras[0] || text.split('\n')[0] || text;
  const rest = text.slice(first.length).trim();
  return {
    ok: false,
    summary: first,
    highlights: splitHighlights(rest),
    comment: rest,
    raw: text
  };
}

function renderParsedComment(parsed) {
  const sum = escapeHTML(parsed.summary || '');
  const bullets = (parsed.highlights || []).map(li => `<li>${escapeHTML(li)}</li>`).join('');
  const com = escapeHTML(parsed.comment || '');

  return `
    <div class="sect">
      <div class="sect-title">1) 현재 대화맥락 요약</div>
      <div class="sect-body">${sum || '—'}</div>
    </div>
    <div class="sect">
      <div class="sect-title">2) 코멘트 중요사항</div>
      ${bullets ? `<ul class="bullets">${bullets}</ul>` : '<div class="sect-body">—</div>'}
    </div>
    <div class="sect">
      <div class="sect-title">3) 코멘트</div>
      <div class="sect-body">${com || '—'}</div>
    </div>
  `.trim();
}


=========================== FILE: renderer/style.css ===========================
(size: 3263 bytes)


:root {
  /* 원하는 크기로 조절 (예: 44px, 56px 등) */
  --icon-size: 48px;
  --glass-bg: rgba(255,255,255,0.72);   /* 좀 더 진하게 */
  --glass-brd: rgba(0,0,0,0.10);
  --text: #111;
  --shadow: 0 8px 28px rgba(0,0,0,.18);
  --icon-blur: 6px;                      /* 아이콘 뒤 블러 */
  --tooltip-bg: rgba(255,255,255,0.86);  /* 툴팁 배경 더 진하게 */
  --tooltip-blur: 4px;                   /* 툴팁 블러 낮춤 */
}

/* 선택: DOM 이벤트 소음 줄이기 */
#root { pointer-events: none; }
#icon, #tooltip, #tooltip * { pointer-events: auto; }


* { box-sizing: border-box; }
html, body {
  margin: 0;
  padding: 0;
  width: 100vw;
  height: 100vh;
  background: transparent;
  overflow: hidden;
  font-family: "Pretendard", system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans KR", "Apple SD Gothic Neo", "Malgun Gothic", sans-serif;
}

#root { position: fixed; inset: 0; pointer-events: none; } /* 전체는 클릭 통과 */

.icon {
  position: absolute;
  left: 60px; top: 60px;
  width: var(--icon-size); height: var(--icon-size);
  border-radius: 999px;
  background: var(--glass-bg);
  backdrop-filter: blur(var(--icon-blur));
  border: 1px solid var(--glass-brd);
  box-shadow: var(--shadow);
  display: grid; place-items: center;
  cursor: grab;
  pointer-events: auto;  /* 아이콘만 포인터 허용 */
  user-select: none;
  z-index: 1000;
}

/* 아이콘 이미지를 원형으로 채우기 */
#icon-img{
  width:100%;
  height:100%;
  border-radius:inherit;  /* .icon의 999px 그대로 상속 */
  object-fit:cover;       /* 꽉 채우기(잘림 허용) */
  object-position:50% 40%;/* 얼굴이 중앙보다 약간 위면 살짝 올리기. 필요시 조절 */
  pointer-events:none;    /* 이미지가 드래그/클릭을 가로채지 않게 */
  z-index: 1001;
}

.icon:active { cursor: grabbing; }
.icon svg { fill: none; stroke: #222; }

.spinner {
  position: absolute; inset: -8px;      /* 아이콘 커진 만큼 테두리 조금 넓힘 */
  border: 2px solid transparent;
  border-top-color: #333; border-right-color: #333;
  border-radius: 999px;
  animation: spin 1s linear infinite;
}

.hidden { display: none; }
@keyframes spin { to { transform: rotate(360deg); } }

.tooltip {
  position: absolute;
  max-width: 360px; min-width: 240px;
  padding: 12px 14px;
  border-radius: 14px;
  background: var(--tooltip-bg);        /* 더 진한 배경 */
  backdrop-filter: blur(var(--tooltip-blur)); /* 블러 강도 낮춤 */
  border: 1px solid var(--glass-brd);
  box-shadow: var(--shadow);
  color: var(--text);
  font-size: 14px; line-height: 1.5;
  pointer-events: auto;
  z-index: 1001;
}

.tooltip { cursor: pointer; }  /* 클릭하면 닫힌다는 걸 시각적으로 암시 */

#tooltip-text { white-space: pre-wrap; word-break: break-word; }

.tooltip .sect { margin-top: 6px; }
.tooltip .sect:first-child { margin-top: 0; }
.tooltip .sect-title {
  font-weight: 600;
  font-size: 13px;
  margin-bottom: 4px;
}
.tooltip .sect-body { white-space: pre-wrap; }
.tooltip ul.bullets {
  margin: 0 0 0 18px;
  padding: 0;
}
.tooltip ul.bullets li { margin: 2px 0; }

================================ END OF BUNDLE =================================
